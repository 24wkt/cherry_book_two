#[4.3]ブロック
#ブロックはメソッドの引数として渡すことができる処理のかたまりです。
#ブロック内で記述した処理は必要に応じてメソッドから呼び出されます。最初はわかりづらいので他の言語と比較しながらRubyのブロックを理解していきましょう。

#[4.3.1]参考：Javaの繰り返し処理
# EX Javaの繰り返し処理
  int nunmber[] = {1, 2, 3, 4};
  int sum = 0;
  for (int i = 0; i < numbers.length; i++) {
      sum += numbers[i];
  }
  system.out.println(sum);  # ==> 10

  #C言語でも同じような構文を使うので、この形式に見慣れている方も多いかもしれません。ここではプログラマがコンピュータに対して次のような処理を明示的に命令しています。

  # ①変数iを０で初期化しろ  (int i = 0)
  # ②ループが1回終わるごとにiの値を1増やす  (i++)
  # ③配列numbersに入っているi番目の値を取り出せ (numbers[i])
  # ④変数sumに取り出した値を加算しろ  (sum += numbers[i])
  # ⑤iが配列numbersの長さよりも小さい間は②〜④の処理を繰り返せ (i < numbers.length)

# EX J2SE 5.0以降では次のような構文(拡張forループ)で配列処理ができる
  int number[] = {1, 2, 3, 4}
  int sum = 0;
  for (int n: number) {
    sum += n;
  }
  system.out.prinln(sum)  # ==> 10

  #この構文ではコンピュータに対する命令がかなり減っています。

  # ①配列numbersの値を順番に変数nに格納しろ  (for (int n: number))
  # ②変数sumに変数nの値を加算しろ (sum += n)

#ここではJavaを例にあげましたが、その他の言語でもforやforeachといった構文をよく見かけます。では、Rubyの場合はどうなのでしょうか？

#[4.3.2]Rubyの繰り返し処理
#Rubyにもfor文はあります。ですが、ほとんどのRubyプログラマはfor文を使いません。
#Rubyの場合はforのような構文で繰り返し処理をさせるのではなく、配列自身に対して「繰り返せ」という命令を送ります。
#ここで登場するのが「eachメソッド」です！

# EX eachメソッドで先程の処理を書いてみる
  numbers = [1, 2, 3, 4]
  sum = 0
  numbers.each do |n|
    sum += n
  end
  puts sum    # ==> 10

#考え方は先程のJavaの拡張ループに近いです。ですが「numbers.each」となっている点に注目してください。
#これはRubyが言語機能として繰り返し処理を実行しているのではなく、配列のeachメソッドが繰り返しを実行させているのです。
#「eachメソッド」の役割は配列の要素を最初から最後まで順番に取り出せることです。しかし、取り出せた要素をどう扱うのかは、その時の要件で変わってきます。
#そこで登場するのが「ブロック」です。
#配列の要素を順番に取り出す作業はeachメソッドで行い、その要素どう扱うかはブロックに記述します。上のコードでいうとdoからendまでがブロックになります。

  ブロックの範囲
  numbers.each do |n|
    sum += n
  end

#|n|のnはブロック引数と呼ばれるもので、eachメソッドから渡された配列の要素が入ります。
#具体的にいうと、nには1,2,3,4が順番に渡されます。ブロック内部では自由にRubyコードをかけます。ここではsum += nのように、変数sumに配列の各要素nを加算するコードを書きました。
#結果として、上記コードではforループと同じように、配列の中身を順に加算していくコードを書いたことになります。

#[4.3.3]配列の要素を削除する条件を自由に指定する
#ブロックは非常によく使われるのでm￥、each以外の使用例も見ておきましょう。例えば、配列には指定した値に一致する要素を削除するdeleteというメソッドがあります。

# EX deleteメソッド
  a = [1, 2, 3, 1, 2, 3]
  #配列から値が2の要素を削除する
  a.delete(2)
  puts a    # ==> a = [1, 3, 1, 3]

  # ==> しかし、deleteメソッドを引数に使うと引数で渡した値に完全一致する要素しか削除できません。
  #　　　そのため、deleteメソッドでは「奇数だけを削除する」という処理を実現できません。
  
#上記のような場合には「deleteメソッド」ではなく「delete_ifメソッド」を使います。

# EX delete_ifメソッド
  a = [1, 2, 3, 1, 2, 3]
  #配列から値が奇数の要素を削除する。
  a.delete_if do |n|
    n.odd?
  end
  puts a    # ==> a = [2, 2]

  # ==> delete_ifメソッドもeachメソッドと同じように、配列の要素を順番に取り出します。そして、その要素をブロックに渡します。
  #     つまり、eachの場合と同じく、上のコードでもブロック引数nに１、２、３、１、２、３が順番に渡されるわけです。

  # ==> しかし、そこから後の処理はeachメソッドと異なります。delete_ifメソッドでは戻り値をチェックします。
  #     その戻り値が真であればmブロックに要素を配列から削除します。偽であれば配列に残したままにします。

  # ==> ブロックの戻り値はメソッドと同様、最後に評価された式になります。上のコードではn.odd?の結果がブロックの戻り値です。
  #     odd?メソッドは数値が奇数の場合にtrueを返します。よって、上記のコードを実行すると配列から奇数の要素が削除されます。

#delete_ifメソッドは「配列の要素を順番に取り出すこと」と「ブロックの戻り値が真であれば要素を削除すること」という共通処理を提供します。
#しかし、どの要素を削除したいのかは要件によって異なるので、ブロックに処理を委ねます。プログラマはブロックの内部に自分の要件に合った処理を記述し、delete_ifメソッドの仕様に合わせて真または偽を返すようにします。

#このように、Rubyでは「要件を問わず共通する処理」はメソッド自身に、「要件によって異なる処理」はブロックにそれぞれ分担させて、1つの処理を完了させるメソッドが数多く用意されています。

#[4.3.4]ブロック引数とブロック内の変数
#もう一度、最初に紹介した配列の要素を加算する処理を見てみましょう。
  numbers = [1, 2, 3, 4]
  sum = 0
  numbers.each do |n|
    sum += n
  end

  #ブロック引数のnは別にnでなくても構いません。引数の名前はプログラマが自由に決めることができます。
  #ブロック引数を使わない場合は、ブロック引数自体を省略できます。

#ここまではブロックの内部には1行しかコードが登場しませんでしたが、ブロック内にはRubyのコードを自由に書くことができます。
# EX 偶数のみ、値を10倍にしてから加算するコード
  numbers a = [1, 2, 3, 4]
  sum = 0
  numbers.each do |n|
    sum_value = n.even? ?n * 10 : n
    sum += sum_value
  end

  # ==> sum_valueはブロック内でも初めて登場した変数です。このような変数のスコープ(有効範囲)はブロックの内部のみになります。
  #     もし、ブロックの外でsum_valueを参照するとエラーになります。

  numbers a = [1, 2, 3, 4]
  sum = 0
  numbers.each do |n|
    # sum_valueはブロック内で初めて登場した変数なので、ブロック内でのみ有効
    sum_value = n.even? ?n * 10 : n
    sum += sum_value
  end
  # ブロックの外に出ると、sum_valueは参照できない
  puts sum_value    # ==> (NameError) undefined local variable or method `sum_value' for main:Object


  # ==> 一方、上のコードの変数sumのように、ブロック外部で作成されたローカル変数はブロックの内部でも参照できます。
  numbers a = [1, 2, 3, 4]
  sum = 0
  numbers.each do |n|
    sum_value = n.even? ?n * 10 : n
    # sumはブロックの外で作成されたので、ブロックの内部でも参照可能
    sum += sum_value
  end

  # ==> ブロック引数の名前をブロックの外にある変数の名前と同じようにすると、ブロック内ではブロック引数の値が優先して参照されます。
  #     (名前の重複により、他の変数やメソッドが参照できなることをシャドーイングといいます。)
  numbers = [1, 2, 3, 4]
  sum = 0
  sum_value = 100
  # ブロックの外にもsum_valueはあるが、ブロック内ではブロック引数のsum_valueが優先される。
  numbers.each do |sum_value|
    sum += sum_value
  end
  puts sum    # ==> 10

  # ==> しかし、このようなコードは読み手を混乱させやすく、思わぬ不具合の原因になったりするので、意図的に同じ名前を使うことは避けましょう！

#[4.3.5]do … endと{}
#ここまでブロックは必ず改行を入れて書きました。しかし、Rubyの文法上、改行を入れなくてもブロックは動作します。

numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n|　sum += n　end
puts sum    # ==> 10

#しかし、これだと可読性に劣ります。
#実はRubyにはもうひとつブロックの記法があります。「do ... end」を使う代わりに、{}で囲んでもブロックを作れます。

numbers = [1, 2, 3, 4]
sum = 0
numbers.each { |n|　sum += n }
puts sum    # ==> 10

# do ... endと{}はどちらも同じブロックなので、{}を使い、ブロックの内部を改行させることも可能です。

numbers = [1, 2, 3, 4]
sum = 0
numbers.each { |n|　
  sum += n
}
puts sum    # ==> 10

#do ... endと{}の使い分けは明確には決まっているわけではありませんが、ここで紹介したように
# ・改行を含む長いブロックを書く場合はdo ... end
#　・1行でコンパクトに書きたい時は{}