#[4.7]配列についてもっと詳しく

#-----------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.1]さまざまな要素の取得方法
#添字を2つ使うと、添字の位置と取得する長さを指定することができます。この場合、配列が返ってきます。

  配列[位置, 取得する長さ]

# EX 2つ目の要素から3つ分の要素を取り出すコード
  a = [1, 2, 3, 4, 5]
  puts a[1,3]
  # ==> [2, 3, 4]

#values_atメソッドを使うと、取得したい要素の添字を複数指定できます。
  a = [1, 2, 3, 4, 5]
  puts a.values_at(0, 2, 4)
  # ==> [1, 3, 5]

#「配列の長さ -1」を指定すれば、最後の要素を取得できます。
  a = [1, 2, 3, 4, 5]
  puts a[a.size - 1]    # <== 最後の要素を取得する
  # ==> 5

#ですが、Rubyでは添字に負の値が使えます。
#「-1は最後の要素」「-2は最後から2番目の要素」というように指定ができます。

# EX
  a = [1, 2, 3]
  puts a[-1]      #最後の要素を取得する
  # ==> 3

  puts a[-2]      #最後から2番目の要素を取得する
  # ==> 2

  puts a[-2, 2]   #最後から2番目の要素から2つの要素を取得する
  # ==> [2, 3]

#さらにいうと、配列にはlastメソッドがあります。
#これを呼ぶと配列の最後の要素を取得できます。引数に０以上の数値を渡すと、最後のn個のよう取得できます。

  a = [1, 2, 3]
  puts a.last
  # ==> 3

  puts  a.last(2)
  # ==> [2, 3]

#lastの反対のfirstもあります。これは先頭の要素を取得するメソッドです。
  
  a = [1, 2, 3]
  puts a.first
  # ==> 1

  puts a.first(2)
  # ==> [1, 2]

#---------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.2]様々な要素の変更方法
#値を変更する場合の負の添字が使えます。
#ただし、姓の値を使う場合と異なり、元の大きさを超えるような添字を指定するとエラーとなります。

  a = [1, 2, 3]
  a[-3] = -10
  puts a
  # ==> [-10, 2, 3]

  # 指定可能な負の値よりも小さくなるとエラーが発生する
  puts a[-4] = 0
  # ==> (IndexError)index -4 too small for array; minimum: -3

#開始位置と長さを指定して要素を置き換えることもできます。

  a = [1, 2, 3, 4, 5]
  # 2つ目から３要素ぶんを100で置き換える
  a[1, 3] = 100
  puts a
  # ==> [1, 100, 5]

#「<<」だけでなく、pushメソッドを使っても要素を追加できます。pushメソッドの場合は複数の値を追加することができます。

  a = []
  a.push(1)
  puts a
  # ==> [1]

  a.push(2, 3)
  puts a
  # ==> [1, 2, 3]

#指定した値に一致する要素を削除したい場合はdeleteメソッドを使います。

  a = [1, 2, 3, 1, 2, 3]
  # 値が2である要素を削除する（削除した値が戻り値になる）
  a.delete(2)
  puts a
  # ==> [1, 3, 1, 3]

  # 存在しない値を指定するとnilが返ってくる
  puts a.delete(5)
  # ==> nil
  puts a
  # ==> [1, 3, 1, 3]

#----------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.3]配列の連結
#2つの配列を連結したい場合はconcatメソッドか、+演算子を使います。違いは元の配列を変更するかどうか(破滅的かどうか)という点です。
#concatメソッドを使って配列を連結すると、元の配列(メソッドを呼び出した側の配列)が変更されます。
# EX concatメソッドを使った場合
  a = [1]
  b = [2, 3]
  puts a.concat(b)
  # ==> [1, 2, 3]

  #aは変更される(破滅的)
  puts a
  # ==> [1, 2, 3]

  #bは変更されない
  puts b
  # ==> [2, 3]

#一方で「+」を使うと元の配列を変更せず、新しい配列を作成します。
# EX 「+演算子」を使った場合
  a = [1]
  b =[2, 3]
  puts a + b
  # ==> [1, 2, 3]

  #aもbも変更されていない(非破滅的)
  puts a
  # ==> [1]
  puts b
  # ==> [2, 3]

#どちらも「配列を連結する」という用途は同じですが、破滅的な変更は大きなプログラムやフレームワークの中では思いがけないところに悪影響を与えてしまう場合があります。
#なので「どうしても」という場合以外は「+演算子」を使うようにしましょう。
#----------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.4]配列の和集合、差集合、積集合
#Rubyの配列は「|, -, &」を使って、和集合、差集合、積集合を求められます。

#「|」は和集合を求める演算子です。2つ目の配列の要素を全て集め、重複しないようにして返します。
# EX |を使った和集合
  a = [1, 2, 3]
  b = [3, 4, 5]
  puts a | b
  # ==> [1, 2, 3, 4, 5]

#「-」は差集合を求める演算子です。左の配列から右の配列に含まれる要素を取り除きます。
# EX -を使った場合
  a = [1, 2, 3]
  b = [3, 4, 5]
  puts a - b
  # ==> [1, 2]

#「&」は積集合を求める演算子です。2つの配列に共通する要素を返します。
# EX &を使った場合
  a = [1, 2, 3]
  b = [3, 4, 5]
  puts a & b
  # ==> [3]

#いずれの演算子も元の配列は変更しません(=非破滅的)
#なお、Rubyには入れるようりも効率的に集合を扱えるsetクラスもあります。本格的な集合演算をする場合は、配列よりSetクラスを使うほうが良いでしょう。
# EX Setクラスを使う場合

  require 'set'

  a = Set.new([1, 2, 3])
  b = Set.new([3, 4, 5])
  puts a | b
  # ==> #<Set: {1, 2, 3, 4, 5}>
  puts a - b
  # ==> #<Set: {1, 2}>
  puts a & b
  # ==> #<Set: {3}>

#------------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.5]多重代入で残りの全要素を配列として受け取る
#多重代入では左辺の変数よりも右辺の個数が多い場合は、はみ出した値が切り捨てられると説明しました。([2.2.8]変数(ローカル変数)の宣言と代入、[4.2.2]配列を使った多重代入)
# EX 右辺が多かった場合に切り捨てられる
  e,f = 100, 200, 300
  puts e
  # ==> 100
  puts f
  # ==> 200

#しかし、左辺の変数に*を付けると、残りの全要素を配列として受け取れる。
# EX *を使った場合
  e, *f = 100, 200, 300
  puts e
  # ==> 100
  puts f
  # ==> [200, 300]