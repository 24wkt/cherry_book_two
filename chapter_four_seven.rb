#[4.7]配列についてもっと詳しく

#-----------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.1]さまざまな要素の取得方法
#添字を2つ使うと、添字の位置と取得する長さを指定することができます。この場合、配列が返ってきます。

  配列[位置, 取得する長さ]

# EX 2つ目の要素から3つ分の要素を取り出すコード
  a = [1, 2, 3, 4, 5]
  puts a[1,3]
  # ==> [2, 3, 4]

#values_atメソッドを使うと、取得したい要素の添字を複数指定できます。
  a = [1, 2, 3, 4, 5]
  puts a.values_at(0, 2, 4)
  # ==> [1, 3, 5]

#「配列の長さ -1」を指定すれば、最後の要素を取得できます。
  a = [1, 2, 3, 4, 5]
  puts a[a.size - 1]    # <== 最後の要素を取得する
  # ==> 5

#ですが、Rubyでは添字に負の値が使えます。
#「-1は最後の要素」「-2は最後から2番目の要素」というように指定ができます。

# EX
  a = [1, 2, 3]
  puts a[-1]      #最後の要素を取得する
  # ==> 3

  puts a[-2]      #最後から2番目の要素を取得する
  # ==> 2

  puts a[-2, 2]   #最後から2番目の要素から2つの要素を取得する
  # ==> [2, 3]

#さらにいうと、配列にはlastメソッドがあります。
#これを呼ぶと配列の最後の要素を取得できます。引数に０以上の数値を渡すと、最後のn個のよう取得できます。

  a = [1, 2, 3]
  puts a.last
  # ==> 3

  puts  a.last(2)
  # ==> [2, 3]

#lastの反対のfirstもあります。これは先頭の要素を取得するメソッドです。
  
  a = [1, 2, 3]
  puts a.first
  # ==> 1

  puts a.first(2)
  # ==> [1, 2]

#---------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.2]様々な要素の変更方法
#値を変更する場合の負の添字が使えます。
#ただし、姓の値を使う場合と異なり、元の大きさを超えるような添字を指定するとエラーとなります。

  a = [1, 2, 3]
  a[-3] = -10
  puts a
  # ==> [-10, 2, 3]

  # 指定可能な負の値よりも小さくなるとエラーが発生する
  puts a[-4] = 0
  # ==> (IndexError)index -4 too small for array; minimum: -3

#開始位置と長さを指定して要素を置き換えることもできます。

  a = [1, 2, 3, 4, 5]
  # 2つ目から３要素ぶんを100で置き換える
  a[1, 3] = 100
  puts a
  # ==> [1, 100, 5]

#「<<」だけでなく、pushメソッドを使っても要素を追加できます。pushメソッドの場合は複数の値を追加することができます。

  a = []
  a.push(1)
  puts a
  # ==> [1]

  a.push(2, 3)
  puts a
  # ==> [1, 2, 3]

#指定した値に一致する要素を削除したい場合はdeleteメソッドを使います。

  a = [1, 2, 3, 1, 2, 3]
  # 値が2である要素を削除する（削除した値が戻り値になる）
  a.delete(2)
  puts a
  # ==> [1, 3, 1, 3]

  # 存在しない値を指定するとnilが返ってくる
  puts a.delete(5)
  # ==> nil
  puts a
  # ==> [1, 3, 1, 3]

#----------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.3]配列の連結
#2つの配列を連結したい場合はconcatメソッドか、+演算子を使います。違いは元の配列を変更するかどうか(破滅的かどうか)という点です。
#concatメソッドを使って配列を連結すると、元の配列(メソッドを呼び出した側の配列)が変更されます。
# EX concatメソッドを使った場合
  a = [1]
  b = [2, 3]
  puts a.concat(b)
  # ==> [1, 2, 3]

  #aは変更される(破滅的)
  puts a
  # ==> [1, 2, 3]

  #bは変更されない
  puts b
  # ==> [2, 3]

#一方で「+」を使うと元の配列を変更せず、新しい配列を作成します。
# EX 「+演算子」を使った場合
  a = [1]
  b =[2, 3]
  puts a + b
  # ==> [1, 2, 3]

  #aもbも変更されていない(非破滅的)
  puts a
  # ==> [1]
  puts b
  # ==> [2, 3]

#どちらも「配列を連結する」という用途は同じですが、破滅的な変更は大きなプログラムやフレームワークの中では思いがけないところに悪影響を与えてしまう場合があります。
#なので「どうしても」という場合以外は「+演算子」を使うようにしましょう。
#----------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.4]配列の和集合、差集合、積集合
#Rubyの配列は「|, -, &」を使って、和集合、差集合、積集合を求められます。

#「|」は和集合を求める演算子です。2つ目の配列の要素を全て集め、重複しないようにして返します。
# EX |を使った和集合
  a = [1, 2, 3]
  b = [3, 4, 5]
  puts a | b
  # ==> [1, 2, 3, 4, 5]

#「-」は差集合を求める演算子です。左の配列から右の配列に含まれる要素を取り除きます。
# EX -を使った場合
  a = [1, 2, 3]
  b = [3, 4, 5]
  puts a - b
  # ==> [1, 2]

#「&」は積集合を求める演算子です。2つの配列に共通する要素を返します。
# EX &を使った場合
  a = [1, 2, 3]
  b = [3, 4, 5]
  puts a & b
  # ==> [3]

#いずれの演算子も元の配列は変更しません(=非破滅的)
#なお、Rubyには入れるようりも効率的に集合を扱えるsetクラスもあります。本格的な集合演算をする場合は、配列よりSetクラスを使うほうが良いでしょう。
# EX Setクラスを使う場合

  require 'set'

  a = Set.new([1, 2, 3])
  b = Set.new([3, 4, 5])
  puts a | b
  # ==> #<Set: {1, 2, 3, 4, 5}>
  puts a - b
  # ==> #<Set: {1, 2}>
  puts a & b
  # ==> #<Set: {3}>

#------------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.5]多重代入で残りの全要素を配列として受け取る
#多重代入では左辺の変数よりも右辺の個数が多い場合は、はみ出した値が切り捨てられると説明しました。([2.2.8]変数(ローカル変数)の宣言と代入、[4.2.2]配列を使った多重代入)
# EX 右辺が多かった場合に切り捨てられる
  e,f = 100, 200, 300
  puts e
  # ==> 100
  puts f
  # ==> 200

#しかし、左辺の変数に*を付けると、残りの全要素を配列として受け取れる。
# EX *を使った場合
  e, *f = 100, 200, 300
  puts e
  # ==> 100
  puts f
  # ==> [200, 300]
#---------------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.6]1つの配列を複数の引数として展開する
#pushメソッドの説明ではa.push(2, 3)のようにして、複数の要素を一度に追加できると説明しました。

  a = []
  a.push(1)
  puts a
  # ==> [1]
  a.push(2, 3)
  puts a
  # ==> [1, 2, 3]

#もし、この２、３が配列になっていた場合はどうなるでしょうか？

  a = []
  b = [2, 3]
  a.push(1)
  puts a
  # ==> [1]

  #配列をそのまま追加する(a.push([2, 3])と同じ)
  a.push(b)
  puts a
  # ==> [1, [2, 3]]

#ご覧の通り、２つの要素ではなく、1つの配列として要素が追加されてました。メソッドの引数に配列を渡すとき、「１つの配列」ではなく、
#配列を展開して「複数の引数」として渡したい場合は、配列の前に「*」を置きます(splat展開)。

  a = []
  b = [2, 3]
  a.push(1)
  puts a
  # ==> [1]

  #配列を*付きで追加する(a.push(2, 3)と同じ)
  a.push(*b)
  puts a
  puts a.last
  # ==. [1, 2, 3]

#変数に入っているとピンとこないかもしれませんが、イメージ的には下のような動作になっています。

  a.push(*b)
  ↓
  a.push(*[2, 3])
  ↓
  a.push(2, 3)

#配列を引数に渡す場合は、「1つの配列」として渡したいのか検討し、「複数の引数」として渡したいのかを検討し、
#後者の場合は「*」を使って配列を展開できることを覚えておきましょう。
#-----------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.7]メソッドの可変長引数
#先ほど見た配列のpushメソッドのように、個数に制限のない引数のことを可変長引数といいます。
#自分で定義するメソッドで可変長引数を使いたい場合は、引数名の手前に「*」をつけます。

def メソッド名(引数1, 引数2, *可変長引数)
  # メソッド処理
end

#可変長引数は配列として受け取ることができます。
# EX 次は引数として渡された人名の全員に挨拶をするメソッドです。
#(コードで使われるjoinメソッドは、引数の区切り文字を使って配列を1つの文字列にするメソッドです。)
def greeting(*names)
  "#{names.join('と')}、こんにちは！"
end

puts greeting('田中さん')
puts greeting('田中さん', '鈴木さん')
puts greeting('田中さん', '鈴木さん', '佐藤さん')

#-----------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.8]「*」で配列同士を非破滅的に連結する
#[]の中に「*」付きで別の配列を置くと、その配列が展開されて別々の要素となります。これもsplat展開の一種です。

a = [1, 2, 3]

#[]の中にそのまま配列を置くと、配列の配列なる。
puts [a]
# ==> [[1, 2, 3]]

#*付きで配列を置くと、展開されて別々の要素になる。
puts [*a]
# ==> [1, 2, 3]

#これを利用すると、別の配列を要素の一部とする新しい配列を作ることができます。

a = [1, 2, 3]
puts [-1, 0, *a, 4, 5]

#「*」ではなく、「+」を使うことができますが、「*」を使った方が簡素なコードになります。

a = [1, 2, 3]
puts [-1, 0] + a + [4, 5]

#------------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.9]「==」で等しい配列かどうか判断する
#「==」を使うと、左辺と右辺の配列が等しいかどうかをチェックできます。
#この場合、配列の全要素を「==」で比較し、すべて等しい場合に「2つの配列は等しい」と判断されます。

#配列が等しい場合
puts [1, 2, 3] == [1, 2, 3]      # ==> true

#配列が等しくない場合
puts [1, 2, 3] == [1, 2, 4]      # ==> false
puts [1, 2, 3] == [1, 2]         # ==> false
puts [1, 2, 3] == [1, 2, 3, 4]   # ==> false

#-------------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.10]%記法で文字列の配列を簡素に作る
#配列は[]を使って作成することが多いですが、文字列については%記法の%wを使って作成する方法が用意されています。
#%記法を使うと、カンマではなく空白文字(スペースや改行)が要素の区切り文字となります。
#また、文字列をシングルクオーテーションやダブルクオーテーションで囲む必要もないため、結果として[]を使う場合よりコードが短くなります。

  # []で文字列の配列を作成する
  puts ['apple', 'melon', 'orange']
  # ==> ["apple", "melon", "orange"]

  # %wで文字列の配列を作成する(!で囲む場合)
  puts %w!apple melon orange!
  # ==> ["apple", "melon", "orange"]

  # %wで文字列の配列を作成する(丸カッコで囲む場合)
  puts %w(apple melon orange)
  # ==> ["apple", "melon", "orange"]

  # 空白文字(スペースや改行)が連続した場合も1つの区切り文字と見なされる
  puts %w(
    apple
    melon
    orange
  )
  # ==> ["apple", "melon", "orange"]

#値にスペースを含めたい場合はバックスラッシュでエスケープします。
  puts %w(big\ apple small\ melon orange)
  # ==> [big apple, small melon, orange]

#式展開や改行文字(\n)、タブ文字(\t)などクォ含めたい場合は、%w(大文字のW)を使います。
  prefix = 'This is'
  puts %w(#{prefix}\ an\ apple small\nmelon orange)
  # ==> ["This is an apple", "small\nmelon", "orange"]

#---------------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.11]文字列を配列に変換する
#文字列を分解して配列にすることもできます。いくつかの方法はありますが、ここではcharsメソッドとsplitメソッドを紹介します。

#charsメソッドは文字列中の1文字1文字を配列の要素に分解するメソッドです。

  puts 'Ruby'.chars
  # ==> ["R", "u", "b", "y"]

#splitメソッドは引数で渡した区切り文字で文字列を配列に分割するメソッドです。

  puts 'Ruby,Java,Perl,PHP'.split(',')
  # ==> ["Ruby", "Java", "Perl", "PHP"]

#この他にも正規表現と組み合わせて文字列を配列変換することができます。
#これについては「[6.3.4]正規表現と組み合わせると便利なStringクラスのメソッド」で説明します。

#---------------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.12]配列に初期値を設定する
#ここまで配列の作成は[]を使ってきましたが、この他にArray.newを使って作成する方法があります。

  # 以下のコードは a = []と同じ
  a = Array.new

#Array.newに引数を渡すと、その個数分の要素が追加されます。この時の初期値はnilです。
  # 要素が5つの配列を作成する
  a = Array.new(5)
  puts a
  # ==> [nil, nil, nil, nil, nil]

#さらに第2引数を指定すると、nil以外の初期値を設定できます。
  # 要素が5つで0を初期値とする配列を作成する
  a = Array.new(5, 0)
  puts a
  # ==> [0, 0, 0, 0, 0]

#Array.newではブロックを使って初期値を設定することもできます。
#ブロック引数には要素の添字が渡されます。配列にはブロックの戻り値がそれぞれ初期値として設定されます。
  # 要素数が10で1, 2, 3, 1, 2, 3...と繰り返す配列を作る
  a = Array.new(10) { |n| n % 3 + 1}
  puts a
  # ==> [1, 2, 3, 1, 2, 3, 1, 2, 3, 1]

#-----------------------------------------------------------------------------------------------------------------------------------------------------------
#[4.7.13]配列に初期値を設定する場合の注意点
#ただし、第2引数を使って初期値を指定する場合は注意が必要です。

  # 要素が５つで'default'を初期値とする配列を作成する
  a = Array.new(5, 'default')
  puts a
  # ==> ["default", "default", "default", "default", "default",]

  # 1番目の要素を取得する
  str = a[0]
  puts str
  # ==> "default"

  # 1番目の要素を大文字に変換する(破滅的変更)
  str.upcase!
  puts str
  # ==> ["DEFAULT"]

  # 配列の要素すべてが大文字に変わってしまった！
  puts a
  # ==> ["DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT",]

#これは配列の全要素が同じ文字列オブジェクトを参照しているために発生する問題です。
#一見、配列の各要素は別々に見えても、実際は一つのオブジェクトに紐付いてしまっているため、そのオブジェクトが変更されると無関係に見えるほかの要素も一緒に変更されてしまうのです。

#この問題を避けるためには引数ではなく、ブロックで初期値を渡すようにします。

  # ブロックを使って、ブロックの戻り値を初期値とする。
  # (ブロック引数には添字が渡されるが、ここでは使わないのでブロック引数を省略)
  a = Array.new(5) {'default'}
  puts a
  # ==> ['default', 'default', 'default', 'default', 'default']

  # 1番目の要素を取得する
  str = a[0]
  puts str
  # ==> 'default'

  #1番目の要素を大文字に変更する(破滅的変更)
  str.upcase!
  puts str
  # ==> 'DEFAULT'

  # 1番目の要素だけが大文字になり、他は変わらない
  puts a
  # ==> ['DEFAULT', 'default', 'default', 'default', 'default',]

#ブロックを使うと、ブロックが呼ばれる度に文字列の'default'が新しく作成されるので、結果として配列の各要素は別々の文字列を参照することになります。
#少しややこしいですが、「同じ値で同一のオブジェクト」なのか「同じ値で異なるオブジェクト」なのか、意識してコードを書かないと思わぬ不具合を作ってしまう可能性があります。

#--------------------------------------------------------------------------------------------------------------------------------------------------------